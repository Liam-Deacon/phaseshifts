"""
Validation helpers for atorb input files.

This module implements a validation layer for the Barbieri/Van Hove 'atorb'
atomic structure code input format. It ensures that the input files—whether
generated by the user or by the high-level Python API—adhere to the strict
formatting and physical constraints required by the underlying Fortran solver.

The validation process acts as a safeguard, catching errors such as invalid
quantum numbers, incorrect grid dimensions, or formatting issues (like
inline comment spacing) that would otherwise cause the legacy Fortran binary
to crash or produce non-physical results.
"""

import os
import warnings
from typing import List

try:
    from pydantic import BaseModel, ValidationError
except ImportError:  # pragma: no cover - pydantic unavailable

    class ValidationError(ValueError):
        """Lightweight stand-in when pydantic is unavailable."""

    class BaseModel(object):
        """Minimal shim to keep type signatures consistent without pydantic."""

        def __init__(self, **data):
            for key, value in data.items():
                setattr(self, key, value)

        @classmethod
        def model_validate(cls, data):
            return cls(**data)

        def model_dump(self):
            return self.__dict__


def coerce_model(model_cls, data):
    """Helper to support pydantic v1/v2 or fallback shim."""
    if hasattr(model_cls, "model_validate"):
        return model_cls.model_validate(data)  # pydantic v2 or shim
    if hasattr(model_cls, "parse_obj"):
        return model_cls.parse_obj(data)  # pragma: no cover - pydantic v1
    return model_cls(**data)  # pragma: no cover - shim safety net


class AtorbElectron(BaseModel):
    """
    Representation of a single electron orbital state in the Dirac-Fock model.

    This class models the quantum numbers and occupancy of an atomic orbital,
    strictly enforcing quantum mechanical selection rules.

    Attributes
    ----------
    n : int
        Principal quantum number (:math:`n \\ge 1`). Determines the energy shell.
    l : int
        Azimuthal quantum number (:math:`0 \\le l < n`). Determines orbital angular momentum.
    m : int
        Magnetic quantum number. Typically unused (0) in spherical averages but required by format.
    j : float
        Total angular momentum quantum number (:math:`j = l \\pm 1/2`).
        Must be a half-integer.
    s : int
        Spin multiplicity/context flag. Typically 1.
    occ : float
        Orbital occupancy number. Can be fractional to represent spherically
        averaged open shells.
    """

    n: int
    l: int
    m: int
    j: float
    s: int
    occ: float

    def ensure_valid(self):
        """
        Run lightweight semantic checks on quantum numbers.

        Verifies:
        - :math:`n > 0`
        - :math:`0 \\le l < n`
        - :math:`s \\in \\{0, 1\\}`
        - Non-negative occupancy
        - :math:`j` is a half-integer

        Returns
        -------
        AtorbElectron
            The validated instance.

        Raises
        ------
        ValidationError
            If any physical constraint is violated.
        """
        if self.n <= 0:
            raise ValidationError("n must be positive for an orbital entry")
        if self.l < 0 or self.l >= self.n:
            raise ValidationError("l must satisfy 0 <= l < n")
        if self.s not in (0, 1):
            raise ValidationError("s must be 0 or 1 for spin multiplicity")
        if self.occ < 0:
            raise ValidationError("occ must be non-negative")
        if abs(self.j * 2) % 1:
            raise ValidationError("j must be a multiple of 0.5")
        return self


class AtorbInputModel(BaseModel):
    """
    Structured representation of an atorb simulation input file.

    This model encapsulates the global parameters for the atomic structure
    calculation (such as grid definition and exchange-correlation method)
    and the list of electronic orbitals.

    Attributes
    ----------
    z : int
        Atomic number (proton count) of the element.
    nr : int
        Number of points in the logarithmic radial grid.
    rel : int
        Relativistic switch. 1 for relativistic (Dirac), 0 for non-relativistic (Schrödinger).
    method : str
        Exchange-correlation potential approximation code (e.g., '0.d0' for Hartree-Fock,
        '1.d0' for LDA).
    relic : float
        Relic parameter passed to the solver (often 0.0).
    nlevels : int
        Total number of electronic orbitals defined.
    mixing_scf : float
        Mixing parameter for the Self-Consistent Field (SCF) iteration (0.0 < x <= 1.0).
    eigen_tol : float
        Convergence tolerance for orbital eigenvalues (in Hartrees).
    ech : int
        Parameter related to the exchange potential configuration.
    orbitals : List[AtorbElectron]
        List of electron orbitals defining the electronic configuration.
    output : str
        Filename for the resulting charge density output file.
    header : str
        Header/Comment line for the input file.
    """

    z: int
    nr: int
    rel: int
    method: str
    relic: float
    nlevels: int
    mixing_scf: float
    eigen_tol: float
    ech: int
    orbitals: List[AtorbElectron]
    output: str
    header: str = ""

    def ensure_valid(self):
        """
        Perform semantic validation on the full input model.

        Checks:
        - Positive Z and NR
        - Valid relativistic flag
        - Consistency between `nlevels` and the length of `orbitals`
        - Recursive validation of all `AtorbElectron` instances

        Returns
        -------
        AtorbInputModel
            The validated instance.

        Raises
        ------
        ValidationError
            If configuration is invalid or inconsistent.
        """
        if self.z <= 0:
            raise ValidationError("Atomic number (Z) must be positive")
        if self.nr <= 0:
            raise ValidationError("Radial grid points (NR) must be positive")
        if self.rel not in (0, 1):
            raise ValidationError(
                "rel must be 0 (non-relativistic) or 1 (relativistic)"
            )
        if self.nlevels != len(self.orbitals):
            raise ValidationError(
                "nlevels ({0}) does not match number of orbital lines ({1})".format(
                    self.nlevels, len(self.orbitals)
                )
            )
        cleaned_orbitals = []
        for orbital in self.orbitals:
            if isinstance(orbital, dict):
                orbital = coerce_model(AtorbElectron, orbital)
            orbital.ensure_valid()
            cleaned_orbitals.append(orbital)
        self.orbitals = cleaned_orbitals
        if not str(self.output).strip():
            raise ValidationError("output filename must be non-empty")
        return self


def _validate_comment_spacing(raw_line, line_no):
    """
    Ensure inline comments are safely separated from data.

    Fortran list-directed input can sometimes misinterpret `!` if it immediately
    follows a number without whitespace. This check warns if such a pattern is detected.

    Parameters
    ----------
    raw_line : str
        The line of text to check.
    line_no : int
        The line number (for error reporting).
    """
    if "!" not in raw_line:
        return
    bang_idx = raw_line.index("!")
    if bang_idx == 0:
        return
    if not raw_line[bang_idx - 1].isspace():
        warnings.warn(
            "Line {0} must contain whitespace before '!' to avoid breaking Fortran list input: {1}".format(
                line_no, raw_line.rstrip()
            ),
            UserWarning,
        )


def _clean_atorb_lines(filename):
    """
    Read and clean lines from an atorb input file.

    Strips comments, whitespace, and empty lines. Also runs the comment spacing
    validation on the raw lines.

    Parameters
    ----------
    filename : str
        Path to the input file.

    Returns
    -------
    list of str
        Cleaned lines containing only data.
    """
    cleaned = []
    with open(filename, "r") as handle:
        for idx, raw_line in enumerate(handle.readlines()):
            _validate_comment_spacing(raw_line, idx + 1)
            stripped = raw_line.rstrip("\n").rstrip("\r")
            if not stripped.strip():
                continue
            if stripped.lstrip().startswith("C"):
                continue
            stripped = stripped.split("!")[0].split("#")[0].strip()
            if stripped:
                cleaned.append(stripped)
    return cleaned


def format_orbital_line(orbital):
    """
    Format a single orbital entry for the input file.

    Parameters
    ----------
    orbital : AtorbElectron
        The orbital data to format.

    Returns
    -------
    str
        A fixed-width/spaced string suitable for Fortran input.
    """
    return "{0:>2d} {1:d} {2:d} {3:>5.1f} {4:d} {5:>14.8f}".format(
        int(orbital.n),
        int(orbital.l),
        int(orbital.m),
        float(orbital.j),
        int(orbital.s),
        float(orbital.occ),
    )


def _check_marker(lines, cursor, marker, description):


    """


    Verify the current line matches the expected marker.





    Parameters


    ----------


    lines : list of str


        The file content.


    cursor : int


        Current line index.


    marker : str


        Expected marker (e.g. 'd', 'x').


    description : str


        Description for error messages.





    Returns


    -------


    int


        The next cursor position.





    Raises


    ------


    ValueError


        If EOF is reached or marker doesn't match.


    """


    if cursor >= len(lines):


        raise ValueError(


            "Unexpected end of file while expecting '{0}' line {1}".format(


                marker, description


            )


        )


    if lines[cursor].lower() != marker.lower():


        raise ValueError("Expected '{0}' line {1}".format(marker, description))


    return cursor + 1








def _parse_z_nr(line):


    """Parse atomic number (Z) and radial grid points (NR)."""


    try:


        return [int(tok) for tok in line.split()[:2]]


    except (ValueError, IndexError):


        raise ValueError("Unable to parse Z and NR from line: {0}".format(line))








def _parse_rel(line):


    """Parse relativistic flag."""


    try:


        return int(line.split()[0])


    except (ValueError, IndexError):


        raise ValueError("Unable to parse relativistic flag from line: {0}".format(line))








def _parse_scf_params(line):


    """Parse Self-Consistent Field parameters."""


    try:


        parts = line.split()[:5]


        return (


            float(parts[0]),


            int(parts[1]),


            float(parts[2]),


            float(parts[3]),


            int(parts[4]),


        )


    except (ValueError, IndexError):


        raise ValueError("Unable to parse SCF parameters from line: {0}".format(line))








def _parse_orbitals(lines, start_cursor, nlevels):


    """Parse orbital definitions from the file lines."""


    orbitals = []


    for i in range(nlevels):


        line_idx = start_cursor + i


        try:


            entry = lines[line_idx].split()


            if len(entry) < 6:


                raise ValueError


            (n, l, m, j, s, occ) = entry[:6]


            orbitals.append(


                {


                    "n": int(n),


                    "l": int(l),


                    "m": int(m),


                    "j": float(j),


                    "s": int(s),


                    "occ": float(occ),


                }


            )


        except Exception:


            raise ValueError(


                "Unable to parse orbital entry on line {0}: {1}".format(


                    line_idx + 1, lines[line_idx]


                )


            )


    return orbitals








def _parse_atorb_file(filename):


    """


    Parse a raw text input file into an AtorbInputModel.





    Reads the strict line-based structure of the atorb input format,


    extracting global parameters and orbital definitions.





    Parameters


    ----------


    filename : str


        Path to the file to parse.





    Returns


    -------


    AtorbInputModel


        The parsed data model.





    Raises


    ------


    ValueError


        If the file structure does not match expected markers ('i', 'd', 'x', 'a', 'w').


    """


    lines = _clean_atorb_lines(filename)


    if not lines:


        raise ValueError("atorb input file {0} is empty".format(filename))





    cursor = 0


    if lines[cursor].lower() != "i":


        raise ValueError("atorb input must start with an 'i' line")


    cursor += 1





    z, nr = _parse_z_nr(lines[cursor])


    cursor += 1





    cursor = _check_marker(lines, cursor, "d", "specifying relativistic flag")


    rel = _parse_rel(lines[cursor])


    cursor += 1





    cursor = _check_marker(


        lines, cursor, "x", "specifying exchange-correlation method"


    )


    method = lines[cursor].split()[0]


    cursor += 1





    cursor = _check_marker(lines, cursor, "a", "specifying SCF parameters")


    relic, nlevels, mixing_scf, eigen_tol, ech = _parse_scf_params(lines[cursor])


    cursor += 1





    orbitals = _parse_orbitals(lines, cursor, nlevels)


    cursor += nlevels





    cursor = _check_marker(lines, cursor, "w", "specifying output filename")


    if cursor >= len(lines):


        raise ValueError("Output filename missing after 'w' line")


    output = lines[cursor].split()[0]





    data = {


        "z": z,


        "nr": nr,


        "rel": rel,


        "method": method,


        "relic": relic,


        "nlevels": nlevels,


        "mixing_scf": mixing_scf,


        "eigen_tol": eigen_tol,


        "ech": ech,


        "orbitals": orbitals,


        "output": output,


        "header": "",


    }





    model = coerce_model(AtorbInputModel, data)


    model.ensure_valid()


    return model


def validate_atorb_file(filename):
    """
    Validate an existing atorb input file.

    Parameters
    ----------
    filename : str
        Path to the input file.

    Returns
    -------
    AtorbInputModel
        The validated model containing the file data.

    Raises
    ------
    IOError
        If file does not exist.
    ValueError
        If file content is invalid.
    """
    if not os.path.isfile(filename):
        raise IOError("atorb input file not found: {0}".format(filename))
    return _parse_atorb_file(filename)


def render_atorb_file(model, filename):
    """
    Render a validated AtorbInputModel to a file on disk.

    Generates a properly formatted text file that can be consumed by the
    Fortran 'atorb' solver. Includes standard comments and separators.

    Parameters
    ----------
    model : AtorbInputModel
        The data model to serialize.
    filename : str
        The destination file path.

    Returns
    -------
    str
        The path to the generated file.
    """
    lines = []
    lines.append("C".ljust(70, "*"))
    header = getattr(model, "header", None)
    lines.append("C {0}".format(header.strip() if header else "atorb input file"))
    lines.append("C".ljust(70, "*"))
    lines.append("i")
    lines.append(
        "{0} {1}".format(model.z, model.nr).ljust(30, " ")
        + " ! Z NR (number of points in radial grid)"
    )
    lines.append("d")
    lines.append("{0}".format(model.rel).ljust(30) + " ! 1=rel, 0=n.r.")
    lines.append("x")
    lines.append(
        "{0}".format(model.method).ljust(30) + " ! 0.d0=HF, 1.d0=LDA, -alfa = xalfa..."
    )
    lines.append("a")
    lines.append(
        "{0} {1} {2} {3} {4}".format(
            model.relic, model.nlevels, model.mixing_scf, model.eigen_tol, model.ech
        ).ljust(30)
        + " ! relic,levels,mixing SCF, eigen. tol,for ech."
    )
    for orbital in model.orbitals:
        lines.append(
            "{0}  ! n, l, l, -j, <1>, occupation".format(format_orbital_line(orbital))
        )
    lines.append("w")
    lines.append("{0}".format(model.output))
    lines.append("q")

    with open(filename, "w") as handle:
        handle.write("\n".join(lines) + "\n")
    return filename
