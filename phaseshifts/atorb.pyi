"This type stub file was generated by pyright and refined with monkeytype."

from typing import Optional, Union, List, Tuple, Any, Dict
from phaseshifts.elements import Element
from phaseshifts.validation.atorb import AtorbInputModel

def get_element(element: Union[str, int], backend: Optional[str] = ...) -> Element:
    """
    Retrieve an element object from the specified chemical data backend.

    This function abstracts the details of various chemistry libraries
    (mendeleev, elementy, periodictable) to provide a unified interface
    for accessing atomic properties like proton count (Z) and electronic
    configurations.

    Parameters
    ----------
    element : str or int
        The symbol (e.g., 'Fe') or atomic number (e.g., 26) of the element.
    backend : str, optional
        The preferred backend library to use ('mendeleev', 'elementy', 'periodictable').
        If None, tries available backends in order.

    Returns
    -------
    Element
        An object containing element data (attributes vary by backend but usually
        include `protons`, `symbol`, `name`).

    Raises
    ------
    LookupError
        If the element cannot be found in any available backend.
    """
    ...

def get_electron_config(element_obj: Element) -> str:
    """
    Extract the electronic configuration string from an element object.

    Retrieves the standard ground-state configuration (e.g., '[Ar] 4s2 3d10 4p5')
    from the backend-specific element object.

    Parameters
    ----------
    element_obj : Element
        The element object returned by `get_element`.

    Returns
    -------
    str
        The electronic configuration string.
    """
    ...

class Atorb:
    r"""
    Wrapper for the `atorb` atomic structure solver.

    This class encapsulates the logic for interacting with the Barbieri/Van Hove
    `atorb` program. It calculates atomic orbitals and radial charge densities
    on a logarithmic grid.

    The solver numerically integrates the radial Dirac equation (or Schrödinger
    equation if relativistic effects are disabled) to find the eigenvalues
    and eigenfunctions of the bound electrons.

    Mathematical Context
    --------------------
    The calculations are performed on a logarithmic radial grid defined by:

    .. math::
        r_i = r_{min} \cdot \left(\frac{r_{max}}{r_{min}}\right)^{\frac{i}{N_R}}, \quad i=1, \dots, N_R

    where :math:`N_R` is the number of grid points. Distances are in Bohr radii
    (:math:`a_0 \simeq 0.529 \mathrm{\AA}`).

    The total spherical charge density :math:`\rho(r)` (in electrons per cubic Bohr)
    is constructed from the radial wavefunctions (stored in internal `phe` arrays):

    .. math::
        \rho(r_i) = \sum_{j=1}^{N_{orb}} \frac{occ_j \cdot |\phi_j(r_i)|^2}{4\pi r_i^2}

    where :math:`occ_j` is the occupancy of the :math:`j`-th orbital.

    For relativistic calculations (Dirac-Fock), the orbital density includes
    both large (:math:`F`) and small (:math:`G`) components:

    .. math::
        |\phi(r)|^2 = F(r)^2 + G(r)^2

    Notes
    -----
    The Breit interaction is neglected, which is a valid approximation for
    valence states dominating the scattering potential in LEED.

    Original author: Eric Shirley

    There are nr grid points, and distances are in Bohr radii
    :math:`a_0 \simeq 0.539 \mathrm{\AA}`

    :math:`r(i) = r_{min} \cdot (r_{max} / r_{min})^{(i/n_r)}`,
    :math:`i=1,2,3,...n_r-1,n_r`

    The orbitals are stored in phe(), first index goes :math:`1...n_r`, the
    second index is the orbital index (:math:`i...n_{el}`)

    Look at the atomic files after printing this out to see everything...
    Suffice it to say, that the charge density at radius :math:`r(i)`
    in units of electrons per cubic Bohr radius is given by:

    :math:`\sum_{j-1}^{n_el}{occ(j) \cdot phe(i,j)^2 / (4.0\,\pi\,{r(i)^2)}}`

    Think of the phe functions as plotting the radial wave-functions
    as a function of radius on a logarithmic mesh...

    The Dirac equation is solved for the orbitals, whereas their density
    is treated by setting :math:`phe(i,j)` to Dirac's
    :math:`\sqrt{F(i,j)^2 + G(i,j)^2}` times the sign of :math:`G(i,j)`...

    So we are doing Dirac-Fock, except that we are not treating exchange
    exactly, in terms of working with major and minor components of the
    orbitals, and the phe's give the CORRECT CHARGE DENSITY...

    The above approximation ought to be very small for valence states,
    so you need not worry about it...

    The Breit interaction has been neglected altogether...it should not
    have a huge effect on the charge density you are concerned with...
    """
    def __init__(self, **kwargs: Any) -> None:
        """
        Initialize the Atorb wrapper.

        Parameters
        ----------
        **kwargs : dict
            Arbitrary attributes to store on the instance.
        """
        ...

    @staticmethod
    def get_quantum_info(shell: str) -> Tuple[int, int, List[float], List[float]]:
        r"""
        Parse quantum numbers from a subshell string (e.g., '3d6').

        Decomposes a standard spectroscopic notation into the set of quantum
        numbers required for the radial equation solver. Handles the splitting
        of shells into spin-orbit coupled states (:math:`j = l \pm 1/2`).

        Parameters
        ----------
        shell : str
            Subshell string, e.g., '1s2', '4f14', '3d5'.

        Returns
        -------
        tuple
            (n, l, j_list, occ_list)

            - **n** (int): Principal quantum number.
            - **l** (int): Azimuthal quantum number.
            - **j_list** (list[float]): Total angular momentum values :math:`j`
              associated with this shell. For :math:`l > 0`, this will be
              [:math:`l-1/2`, :math:`l+1/2`].
            - **occ_list** (list[float]): Occupancy for each :math:`j` level.
              Electrons are distributed according to statistical weight
              (:math:`2j+1`).

        Examples
        --------
        For a full '3d10' shell:

        >>> Atorb.get_quantum_info('3d10')
        (3, 2, [1.5, 2.5], [4.0, 6.0])

        Here, :math:`n=3`, :math:`l=2`. The states are :math:`d_{3/2}` (occupancy 4)
        and :math:`d_{5/2}` (occupancy 6).
        """
        ...

    @staticmethod
    def replace_core_config(electron_config: str) -> str:
        """
        Expand noble gas core abbreviations into full orbital strings.

        The `atorb` solver requires explicit definitions for all orbitals
        starting from 1s. This function replaces '[Ar]', '[Xe]', etc., with
        their constituent subshells.

        Parameters
        ----------
        electron_config : str
            Electronic configuration string, potentially containing noble gas
            cores (e.g., '[Ar] 4s2').

        Returns
        -------
        str
            The fully expanded configuration string.

        Examples
        --------
        >>> Atorb.replace_core_config('[He] 2s1')
        '1s2 2s1'
        """
        ...

    @staticmethod
    def gen_input(element: Union[str, int], **kwargs: Any) -> str:
        """
        Generate the input file for the 'atorb' atomic structure solver.

        This method constructs a formatted input file required by the Barbieri/Van Hove
        'atorb' program (encapsulated in `libphsh`). It determines the electronic
        configuration of the specified element, handles noble gas core expansion,
        and sets up the radial grid and exchange-correlation parameters for the
        Dirac-Fock calculation.

        Parameters
        ----------
        element : str or int
            The chemical symbol (e.g., 'Cu') or atomic number (e.g., 29) of the target element.
        **kwargs : dict, optional
            Configuration options for the calculation:

            output : str
                Filename for the resulting charge density output (default: 'at_<symbol>.i').
            ngrid : int
                Number of points in the logarithmic radial grid (default: 1000).
                Higher values provide better numerical resolution near the nucleus.
            rel : int or bool
                Relativistic flag (default: 1).
                1 (or True): Solve Dirac equations (includes spin-orbit coupling).
                0 (or False): Solve non-relativistic Schrödinger equations.
            filename : str
                Filename for the generated input text file (default: 'atorb_<symbol>.txt').
            header : str
                Comment line at the top of the input file (default: auto-generated).
            method : str
                Exchange-correlation potential approximation (default: '0.d0' for Hartree-Fock).
                '0.d0': Hartree-Fock (HF).
                '1.d0': Local Density Approximation (LDA).
                '-alpha': X-alpha method (requires providing alpha value).
            relic : float
                Mixing parameter for the self-consistency cycle (default: 0.0).
            mixing_SCF : float
                Mixing parameter for Self-Consistent Field convergence (default: 0.5).
            tolerance : float
                Convergence tolerance for orbital eigenvalues (default: 0.0005 Hartrees).
            ech : int
                Parameter for the exchange potential (default: 100).

        Example
        -------
        >>> Atorb.gen_input('H',rel=False,filename="atorb.txt",output='at_H.i')
        >>> with open('atorb_H.txt', 'r') as f: print(""".join(f.readlines()))
         C*********************************************************************
         C  atorb input file: atorb_H.txt.
         C*********************************************************************
         i
         1 1000                   ! Z NR (number of points in radial grid)
         d
         0                        ! 1=rel, 0=n.r.
         x
         0.d0                     ! 0.d0=HF, 1.d0=LDA, -alfa = xalfa...
         a
         0 1 0.5 0.0005 100       ! relic,levels,mixing SCF, eigen. tol,for ech
         1 0 0 -0.5 1 1.0         ! n, l, l, -j, <1>, occupation
         w
         at_H.i
         q

        Returns
        -------
        str
            The path to the generated input file.

        Notes
        -----
        The resulting file allows `libphsh` to solve the radial Dirac equation:

        .. math::
            H \Psi = E \Psi

        where density functional theory (DFT) or Hartree-Fock approximations define
        the potential.
        """
        ...

    @staticmethod
    def validate_input_file(input_path: str) -> AtorbInputModel:
        """
        Validate a generated or user-supplied atorb input file.

        Parses the input file using the `phaseshifts.validation.atorb` logic
        to ensure it meets the strict formatting and physical requirements of
        the solver.

        Parameters
        ----------
        input_path : str
            Path to the file to validate.

        Returns
        -------
        AtorbInputModel
            Parsed and validated representation of the input file.
        """
        ...

    @staticmethod
    def calculate_Q_density(**kwargs: Any) -> str:
        """
        Execute the atomic structure calculation to obtain radial charge densities.

        This method serves as the primary driver for the 'atorb' Fortran routine.
        It either generates a new input file based on an element symbol or validates
        an existing input file, then invokes the solver (`hartfock`) via `libphsh`.

        The solver computes the radial wavefunctions :math:`\phi_{n,l,j}(r)` and
        constructs the total spherical charge density :math:`\rho(r)`.

        Parameters
        ----------
        **kwargs : dict, optional
            Keyword arguments passed to :meth:`gen_input` if `element` is provided.

            element : str or int
                Target element. If provided, an input file is generated on-the-fly.
            input : str
                Path to an existing atorb input file. Ignored if `element` is provided.
            output_dir : str
                Directory where the output file (containing phase shifts or charge densities)
                should be placed. Defaults to current directory.

        Returns
        -------
        str
            Path to the output file containing the calculated atomic charge densities.

        Raises
        ------
        ValueError
            If neither `element` nor `input` is specified.
        IOError
            If the output directory cannot be created or accessed.

        Examples
        --------
        >>> Atorb.calculate_Q_density(input='atorb_C.txt')
              18.008635    -33.678535
               4.451786    -36.654271
               1.569616    -37.283660
               0.424129    -37.355634
               0.116221    -37.359816
               0.047172    -37.360317
               0.021939    -37.360435
               0.010555    -37.360464
               0.005112    -37.360471
               0.002486    -37.360473
               0.001213    -37.360473
               0.000593    -37.360473
               0.000290    -37.360474
            N L M J S OCC.
            1   0 0  -1/2   1    2.0000        -11.493862
            2   0 0  -1/2   1    2.0000         -0.788618
            2   1 1  -1/2   1    0.6667         -0.133536
            2   1 1  -3/2   1    1.3333         -0.133311
         TOTAL ENERGY =      -37.360474  -1016.638262

        >>> Atorb.calculate_Q_density(element='H')
               0.500007     -0.343752
               0.152392     -0.354939
               0.065889     -0.357254
               0.028751     -0.357644
               0.012732     -0.357703
               0.005743     -0.357711
               0.002641     -0.357712
               0.001236     -0.357713
               0.000587     -0.357713
               0.000282     -0.357713
         N L M J S OCC.
            1   0 0  -1/2   1    1.0000         -0.229756
         TOTAL ENERGY =       -0.357713     -9.733932


        """
        ...
